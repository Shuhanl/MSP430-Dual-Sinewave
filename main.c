/************************************************************************
 *
 * Description:	This code turns the LaunchPad into a simple (slow)
 * 				function generator that outputs a sine wave.
 * 				For each point in a period signal, there is one
 * 				smaller PWM period. For this example there are 32
 * 				points per period. The duty cycle of each PWM period
 * 				determines the analog value at that point in time.
 * 				By continually changing the duty cycle, an analog
 * 				signal can be generated by filtering the digital
 * 				output signal. The analog filter can be as simple as
 * 				a single order low-pass filter which has a corner
 * 				frequency slightly greater than the desired signal.
 *
 * 				This code was originally created for MSP 430 F5529
 *
 * 				See http://msp430launchpad.com for more information.
 *
 *
 *				ACLK = n/a, MCLK = SMCLK = default DCO
 *
 * 				Output Frequency = Clock/( # of points * PWM period)
 *
 *               MSP430F5529
 *             ---------------
 *         /|\|               |
 *          | |           P1.0| --> Analog Filters --> Sine Wave
 *          --|RST            |
 *            |               |
 *
 *
 *
 ************************************************************************/
#include <msp430f5529.h>

unsigned char counterA;				// Current location in wave array
unsigned char waveA[32] = {			// Wave array, preset to values of sine
	128, 140, 152, 164, 173, 181, 187, 191,
	192, 191, 187, 181, 173, 164, 152, 140,
	128, 116, 104, 92, 83, 75, 69, 65,
	64, 65, 69, 75, 83, 92, 104, 116 };

unsigned char counterB;				// Current location in wave array
unsigned char waveB[32] = {			// Wave array, preset to values of sine
	128, 140, 152, 164, 173, 181, 187, 191,
	192, 191, 187, 181, 173, 164, 152, 140,
	128, 116, 104, 92, 83, 75, 69, 65,
	64, 65, 69, 75, 83, 92, 104, 116 };

void PortsInit(void)
{
	P1DIR |= BIT0;							// P1.0 output
	P1OUT |= BIT0;							// Set P1.0

	P1DIR |= BIT2;							// P1.2 output
	P1OUT |= BIT2;							// Set P1.2
}
void TimerAInit(void)
{
	counterA = 0;										// Reset counter
	// Initialize Timer
	TA0CCTL0 |= CCIE;									// CCR0 interrupt enabled
	TA0CCTL1 |= CCIE;									// CCR1 interrupt enabled

	TA0CCR0 = 256;										// Set PWM period to 256 clock ticks
	TA0CCR1 = waveA[counterA];							// Set first duty cycle value

	TA0CTL = TASSEL__ACLK + MC_1 + TAIE + TACLR;		// ACLK, up mode, enable interrupt, clear TA1R

}

void TimerBInit(void)
{
	counterB = 0;
	// Initialize Timer
	TB0CCTL0 |= CCIE;									// CCR0 interrupt enabled
	TB0CCTL1 |= CCIE;									// CCR1 interrupt enabled

	TB0CCR0 = 256;										// Set PWM period to 256 clock ticks
	TB0CCR1 = waveB[counterB];							// Set first duty cycle value

	TB0CTL = TBSSEL__ACLK + MC_1 + TBIE + TBCLR;		// ACLK, up mode, enable interrupt, clear TB1R
}
void main(void)
{
	WDTCTL = WDTPW|WDTHOLD;					// Stop WDT
	PortsInit();
	TimerAInit();
	TimerBInit();

	for(;;)
	{
		_BIS_SR(LPM0_bits + GIE);		    // Enter LPM0 w/ interrupt
	}
}


// TimerA0 interrupt service routine

#pragma vector=TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void)
{
	P1OUT |= BIT0;				// Set P1.0

	TA0CCR1 = waveA[counterA];	// Set next duty cycle value
	counterA += 1;				// Add Offset to CCR0
	if ( counterA == 32)		// If counter is at the end of the array
	{
		counterA = 0;			// Reset counter
	}
}

 // TimerA1 Interrupt Vector (TAIV) handler

#pragma vector=TIMER0_A1_VECTOR
__interrupt void TIMER0_A1_ISR(void)
{
	switch( TA0IV )
	{
		case  2:				// CCR1 interrupt
			P1OUT &= ~BIT0;		// Clear P1.0 to determine duty cycle.
			break;
		default:
			break;
	}
}

// TimerB0 interrupt service routine

#pragma vector=TIMER0_B0_VECTOR
__interrupt void TIMER0_B0_ISR(void)
{
	P1OUT |= BIT2;				// Set P1.2

	TB0CCR1 = waveB[counterB];	// Set next duty cycle value
	counterB += 1;				// Add Offset to CCR0
	if ( counterB == 32)		// If counter is at the end of the array
	{
		counterB = 0;			// Reset counter
	}
}

 // //TimerB1 Interrupt Vector (TAIV) handler

#pragma vector=TIMER0_B1_VECTOR
__interrupt void TIMER0_B1_ISR(void)
{
	switch( TB0IV )
	{
		case  2:				// CCR1 interrupt
			P1OUT &= ~BIT2;		// Clear P1.2 to determine duty cycle.
			break;
		default:
			break;
	}
}
